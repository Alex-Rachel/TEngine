using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator]
public class UIResRegistryGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        const string registryClassName = "UIResRegistry";
        var uiHolderType = context.Compilation.GetTypeByMetadataName("TEngine.UIHolderObjectBase");
        var uiResAttribute = context.Compilation.GetTypeByMetadataName("TEngine.UIResAttribute");

        var sb = new StringBuilder(@"// <auto-generated/>
using UnityEngine;
using TEngine;

namespace TEngine
{
    internal static class UIResRegistryInitializer
    {
");

        var registrations = new List<string>(); // 存储所有注册调用代码

        foreach (var classDecl in ((SyntaxReceiver)context.SyntaxReceiver).CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(classDecl.SyntaxTree);
            if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol) continue;

            if (!classSymbol.IsDerivedFrom(uiHolderType)) continue;

            var attribute = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Equals(uiResAttribute, SymbolEqualityComparer.Default) == true);

            if (attribute == null) continue;

            var loadType = (EUIResLoadTypeTest)(attribute.ConstructorArguments[1].Value ?? 0);

            // 生成注册代码行
            registrations.Add(
                $"{registryClassName}.Register(" +
                $"typeof({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}), " +
                $"{classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.ResTag, " +
                $"EUIResLoadType.{loadType});");
        }

        // 生成统一注册方法
        sb.Append(@"
#if UNITY_EDITOR
        [UnityEditor.InitializeOnEnterPlayMode]
#else
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
#endif
        private static void RegisterAll()
        {");

        foreach (var registration in registrations)
        {
            sb.AppendLine()
              .Append("            ")
              .Append(registration);
        }

        sb.Append(@"
        }
    }
}");

        context.AddSource("UIResRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax { BaseList: not null } classDecl)
            {
                if (classDecl.BaseList.Types.Any(t => t.Type.ToString().Contains("UIHolderObjectBase")))
                {
                    CandidateClasses.Add(classDecl);
                }
            }
        }
    }
}

public static class SymbolExtensions
{
    public static bool IsDerivedFrom(this INamedTypeSymbol symbol, INamedTypeSymbol baseType)
    {
        var current = symbol;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
            current = current.BaseType;
        }
        return false;
    }
}